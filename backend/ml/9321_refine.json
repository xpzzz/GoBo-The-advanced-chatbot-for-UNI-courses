[{"word": "Information Systems/Applications Integration","description": "A set of services and solutions for bringing together disparate application and business processes as needed to meet the diverse information requirements of your customers, partners, suppliers and employees.  "},
{"word": "Data Level Integration","description": "combining data from different sources and providing users with a unified 2.  3 Data Integration 23 view over them"},
{"word": "The evolution of programming abstractions","description": "Services: “customer” and “service provider” Lines of code vs.   Services - consider software building exercise as ‘building services’, ‘discovering services’ and ‘combining services’"},
{"word": "The evolution of programming abstractions","description": "In SOA, we talk about software as a service.That is, SOA is about building software systems composed of a collection of (software) services"},
{"word": "Service orientation","description": "a way of integrating your applications as a set of linked services.   If you can define the services, you can begin to link the services to realise more complicated 'services'"},
{"word": "Enterprise Application Integration (EAI)","description": "EAI definition by Hewlett Packard: A set of services and solutions for bringing together disparate application and business processes as needed to meet the diverse information requirements of your customers, partners, suppliers and employees.  "},
{"word": "Characteristics of Top-down Design","description": "1.  goals: Focus first on the high-level objectives, then proceed to define everything required to achieve those goals 2.  tightly coupled: To simplify system development/maintenance, distributed nodes are usually created to run on homogeneous computing environments.   Functionality of one component depends on the functionality of other components.   3.  more control: relatively easy to address both functional and non-functional (e.  g.  , performance) issues 4.  from-scratch-development: few information systems nowadays can be developed this way"},
{"word": "Legacy Systems","description": "a computer system or application program which continues to be used because of the cost of replacing or redesigning it"},
{"word": "Characteristics of Bottom-Up Design","description": "1.  legacy systems: In a bottom up design, many of the basic components already exist.   These are stand-alone systems which need to be integrated into a new system.   2.  loosely coupled: The components do not necessarily cease to work as stand-alone components.   Often old applications continue running at the same time as new applications.   3.  wider usage: This approach is used widely because legacy systems exist and typically cannot be easily replaced.  "},
{"word": "Information System Design","description": "Two approaches: Top-down, Bottom-up"},
{"word": "Architecture of an Information System","description": "1-Tier, 2-Tier, 3-Tier.  "},
{"word": "1-Tier system","description": "users/programs access the system through “dumb” terminals, whose display is controlled by the information system"},
{"word": "2-Tier system","description": "client can have more sophisticated presentation layers while also saving computer resources on the server.   The resource manager still only sees one client: the application logic.   This helps with performance since there are no client connections/sessions"},
{"word": "3-Tier system","description": "Added - application logic layer (aka middleware) introduces an additional layer of business logic encompassing all underlying systems"},
{"word": "The Middleware in 3-Tier","description": "It enables transparent access to the underlying systems, the integration of systems built using other architectures"},
{"word": "N-Tier system","description": "N-Tier: could be 3-Tier plus Web-enablement layer or integration of many 3-Tier systems (modern application servers)"},
{"word": "Communication in a Information System","description": "There are two communication patterns widely used: synchronous and asynchronous.         • synchronous: blocking interaction       • asynchronous: non blocking interaction"},
{"word": "Non Blocking Calls","description": "a call to the server returns immediately and client can continue to run and occasionally check with server to see if a response is ready"},
{"word": "Web applications","description": "Web applications ≈ apps over the Web"},
{"word": "HTTP Request Methods (version 1.1)","description": "GET, HEAD, POST"},
{"word": "Model-View-Controller","description": "1.  Model: Structures your data in a reliable form and prepares it based on controller’s instructions 2.  View: Displays data to user in easy-to-understand format, based on the user’s actions 3.   Controller: Takes in user commands, sends commands to the model for data updates, sends instructions to view to update interface.  "},
{"word": "Flask Web Framework","description": "One of Python’s answers to Web development"},
{"word": "Session Management","description": "There are a number of ways to deal with sessions.   The basic idea: When a user request comes in, besides sending the response, the server also sends an identifier.   The identifier is recorded by the server The identifier will accompany all subsequent requests from the same user When the server receives a request with the same identifier, it can treat the request as belonging to the same user.  "},
{"word": "HTML hidden fields","description": "Use HTML hidden form fields to pass the token/identifier around.  "},
{"word": "URL Rewriting","description": "Append a token or identifier of the session to the URL (all subsequent requests).  "},
{"word": "Cookies","description": "A small piece of data sent from the server – stored in the client’s Web browser       • Supported by all Web frameworks (part of HTTP) – creating/manipulating cookies       • Cookies are set/created in an HTTP header (in Response)"},
{"word": "HTTP Sessions with Python Flask","description": "Most Web frameworks use Cookies to manage sessions Supports the notion via ‘Session’ object.  "},
{"word": "API – Application Programming Interface","description": "The interface is not meant for human interactions – there is another program on the other side à implication of this: you must have a clear contract (e.  g.  , IOU Alice Bob 100)       • These days companies use APIs internally (private APIs) as well as exposing them externally (public APIs)"},
{"word": "RESTful Service","description": "Early XML-based API fell out of favour along with the rise of the number of ‘mobile’ devices (and other ‘non-traditional’ client devices) due to the ‘heavy’ data payload and processing load.   REST is an architectural style of building networked systems - a set of architectural constraints in a protocol built in that style.  "},
{"word": "Resources in REST","description": "The key abstraction of information in REST is a resource.   Any information that can be named can be a resource: a document or image, a temporal service (e.  g.   today’s weather in Los Angeles), a collection of other resources, a nonvirtual object (e.  g.   a person), and so on.   In other words, any concept that might be the target of an author’s hypertext reference must fit within the definition of a resource.   – Roy Fielding’s dissertation.  "},
{"word": "What makes a RESTful Service","description": "REST is an architectural style of building networked systems - a set of architectural constraints in a protocol built in that style.   A RESTful service/API MUST meet the architectural constraints by following the design guide/principles"},
{"word": "Resource URI","description": "Resources are identified by a URI (Uniform Resource Identifier).   A resource has to have at least one URI"},
{"word": "Addressability","description": "An application is ‘addressable’ if it exposes its data set as resources (i.  e.  , usually a large number of URIs)"},
{"word": "Representations","description": "A resource needs a representation for it to be sent to the client.   A representation of a resource - some data about the ’current state’ of a resource"},
{"word": "Description Syntax","description": "Use pure HTTP methods as main operations on resources.   eg.  GET PUT DELETE POST HEAD OPTIONS and PATCH"},
{"word": "POST","description": "POST creates a new resource.   But .  .  .   the server decides on that resource’s URI and returns the new URI for the resource in the response"},
{"word": "PUT","description": "PUT “creates” or “updates” a resource:       • But .  .  .   the URI is given in the request input by client       • if existing, the contained entity is considered as a modified version of the resource"},
{"word": "PATCH","description": "In a PUT request, the enclosed entity is considered to be a modified version of the resource stored on the origin server, and the client is requesting that the stored version be replaced.   With PATCH, however, the enclosed entity contains a set of instructions describing how a resource currently residing on the origin server should be modified to produce a new version.  "},
{"word": "Being Safe","description": "Read-only operations .  .  .   The operations on a resource do not change any server state.   The client can call the operations 10 times, it has no effect on the server state.  "},
{"word": "Being Idempotent","description": "Operations that have the same “effect” whether you apply it once or more than once.   An effect here may well be a change of server state.   An operation on a resource is idempotent if making one request is the same as making a series of identical requests.  "},
{"word": "Why Safety and Idempotency matter","description": "Allows the “Uniformity” in REST interface (≈ accepted convention by the community)"},
{"word": "Linked Resources","description": "The current state of an HTTP ‘session’ is not stored on the server as a resource state, but tracked by the client as an application state, and created by the path the client takes through the Web.   The server guides the client’s path by serving hypermedia: links and forms inside resource representations.  "},
{"word": "Statelessness","description": "REST API must be stateless.   Stateless means every HTTP request happens in a complete isolation.   Stateless is good !! - scalable, easy to cache, addressable URI can be bookmarked (e.  g.  , 10th page of search results)"},
{"word": "On Statelessness","description": "a RESTful service requires that the application state to stay on the client side.   Server does not keep the application state on behalf of a client"},
{"word": "Caching","description": "Responses must be marked ‘cachable’ or ‘non-cachable’"},
{"word": "The Richardson Maturity Model","description": "Leonard Richardson: can we measure to what level your service is RESTful?       Level 0: One URI (single endpoint) exposed, requests contain operation details      Level 1: Expose resource URIs - individual URIs for each resource.   Requests could still contain some operation details     Level 2: HTTP Methods - use the standard HTTP methods, status codes with the resource URIs,     Level 3: HATEOAS - self-documenting responses, responses include links that the client can use"},
{"word": "Layered System","description": "A client cannot ordinarily tell whether it is connected directly to the end server, or to an intermediary along the way.   Again, de-coupling allows the components I the architecture to evolve independently"},
{"word": "Designing RESTful APIs","description": "A well-designed API should make it easy for the clients to understand your service without having to “study” the API documents in-depth.  "},
{"word": "URI design","description": "Identify and “name” the resources.   We want to move away from the RPC-style interface design where lots of ‘operation names’ are used in the URL"},
{"word": "Decide How to Use the Status Codes","description": "Using proper status codes, and using them consistently in your responses will help the client understand the interactions better.  "},
{"word": "Decide your response format","description": "Should support multiple formats and allow the client content negotiation (JSON only?) Use simple objects.   A single result should return a single object.   Multiple results should return a collection - wrapped in a container.  "},
{"word": "HATEOAS","description": "Hypermedia As The Engine Of Application State"},
{"word": "HATEOAS - Hypermedia As The Engine Of Application State","description": "The principle is that a client interacts with a network application entirely through hypermedia provided dynamically by application servers.   A REST client needs no prior knowledge about how to interact with any particular application or server beyond a generic understanding of hypermedia.  "},
{"word": "REST APIs and Security","description": "REST relies on the elements of the Web for security too .  .  .   Basic security properties ?     HTTPS (SSL)           • “Strong” server authentication, confidentiality and integrity protection The only feasible way to secure against man-in-the-middle attacks          • Any security sensitive information in REST API should use SSL"},
{"word": "Authentication","description": "The basic idea revolves around: ”login credentials” (for app, not human)"},
{"word": "HTTP Basic Auth","description": "Issues with HTTP Basic Auth as an API authentication scheme"},
{"word": "The signatures (cryptography technique)","description": "Keyed-Hash Message Authentication Code (HMAC) is an algorithm that combines a certain payload with a secret using a cryptographic hash function.  "},
{"word": "API Key method","description": "From User (API consumer) point of view:           • Sign up for the service, API key for the user is issued by the server           • Copy the issued API key [and secret] in all requests            • ≈ user id and password, except it is meant to be authenticate the ‘client application’"},
{"word": "Standarised API specification","description": "An idea that is increasingly becoming attractive … and this helps RESTful client application development (every aspect of the standard is to help API consumer understand and consume API quicker/less labour intensive way)"},
{"word": "Web and RESTful client to Services","description": "an application may have ‘RESTful client’ embedded so that it can incorporate external APIs            • Understanding, getting to know an API quickly is also a “skill”         • Something like OpenAPI Specification could help here …          • Pure HTTP request/response (stateless) interactions with the API expected     Two types: Simple programmatic interactions with the service         • Using so-called HTTP Client libraries           • Maybe less ”human-based interaction” with the response content"},
{"word": "visualization","description": "Visualization transforms data into images that effectively and accurately represent information about the data.  "},
{"word": "Data Visualisation","description": "Referring to any visual representation of data that is:           • algorithmically drawn (may have custom touches but is largely rendered with the help of computerized methods);              • easy to regenerate with different data (the same form may be repurposed to represent different datasets with similar dimensions or characteristics);            • often aesthetically simple (data is not decorated); and             • relatively data-rich (large volumes of data are welcome and viable, in contrast to infographics).  "},
{"word": "what makes a good visualisation","description": "Accuracy, Story, Knowledge: Aim to create a visualisation that are accurate, tell a good story, and provide real knowledge to the audience"},
{"word": "Data aggregation","description": "Data aggregation is the process where raw data is gathered and expressed in a summary form for statistical analysis"},
{"word": "STACKED Bar graphs","description": "      • Compare data within groups            • Whole bar represents the total value of that group, and each segment represents the value within the group"},
{"word": "Line graphs","description": "      • To show values “over time” or a continuous interval         • Stories over Timeline"},
{"word": "Scatter Plot graphs","description": "To show two variables and their correlations"},
{"word": "Pie Charts","description": "      • Although commonly used, not considered an effective form.   Human brain is not wired to parse round shape areas and arcs              • Normally other graphs can do the same job (e.  g.  , BAR graphs)            • Maybe OK when showing two variables (<, >, similar, etc.  )"},
{"word": "What is in a data model","description": "An application developer “thinks” in terms of the real world (people, organisations, actions, goods, etc.  ) … and model it as objects/data structures and APIs that manipulate them – these models are very specific to each application When you want to store the objects, you express them in generic-purpose data model such as JSON, XML documents or tables.   The “storage” also allows the representation to be queried, searched or manipulated.  "},
{"word": "Relational Model","description": "      • The best known, probably the most successful data model which has proven itself in many aspects to be the data model of choice in many applications       • Data is organised into relations (table) where each relation holds an unordered collection of tuples (rows)"},
{"word": "NoSQL","description": "      • A need for greater scalability – very large datasets or very high ‘write’ throughput       • A need for more expressive and dynamic data model       • Usually do not require a fixed table schema nor do they use the concept of joins       • All NoSQL offerings relax one or more of the ACID properties"},
{"word": "Problems with Relational Models","description": "The Object-Relational Mismatch (Impedance Mismatch)       • Refers to the problem of a mismatch between application data model (your business objects) and data model for storage (in relational tables)       • This mismatch creates a need for an awkward translation layer between the objects in the application code and the database model of tables/row/columns.  "},
{"word": "Added features in SQL","description": "Some databases support an idea similar to ‘Arrays’:       • an store multi values in a single row       • can be queried and indexed"},
{"word": "Which data model leads to simpler application code","description": "      • If the application data model looks like a tree (document-like) -> it can be loaded at once using document-based model       • If M-M relationships are central to the application data model -> relational model is efficient in joins.   If document model is used, some of the ‘join’ logic will have to move to application code"},
{"word": "Schema flexibility","description": "      • Most document-based databases do not enforce any schema in documents (schemaless databases)       • Arbitrary keys and values can be added to a document and when reading clients have no guarantees as to what fields the documents may contain       • Schema-on-read – The structure of the data is implicit, only interpreted when the data is read by application code – ≈ dynamic (runtime) type checking       • Schema-on-write – The traditional approach of RDB - explicit schema and the database ensures all written data conforms to it – ≈ static (compile-time) type checking"},
{"word": "Declarative query paradigm","description": "Declarative query paradigm is good for many reasons: It is up to the database to decide which index tables to consult, which joins should be performed, in which order the various parts of the query are executed The query language can remain concise Any further optimisation/performance improvement of the database system can happen without affecting the query interface (e.  g.  , re-arranging disk space) Suitable for parallel execution strategy …"},
{"word": "Accessing DB from an Application","description": "When you work with a database system (regardless of its storage model) in an application, the code issues a query statements to the database via some form of data-connectivity API"},
{"word": "Directly Executing SQL","description": "SQLAlchemy       • “Uniform” SQL access to relational databases (in SQLAlchemy way)       • i.  e.  , SQL access library built on top of the DBAPI connectivity"},
{"word": "implementation view point","description": "Difficult to obtain a ”single view of X” for any X       • What data do I have about X?       • How do I stitch together the info I need?       • What else is X related to? No uniformity (model or language)       • Data about X is stored in many different formats.         • Accessing or updating X involves many different APIs or access methods       • Manual coding of ”distributed query plans”"},
{"word": "Data as a service","description": "Sourcing, processing and delivery of data in a usable format Often the idea includes designing and implementing a master/central hub (authoritative source) for the data Aims to utilise lightweight, open standards and Web technologies"},
{"word": "ATOM and ATOM Publishing Protocol","description": "Atom represents data as lists, called feeds.   Feeds are made up of one or more timestamped entries, which associate document metadata with web content.   Atom Publishing Protocol (AtomPub), a protocol that is built on top of Atom, and which is used for publishing and editing web resources -> Using HTTP actions"},
{"word": "Common usage of ATOM","description": "Syndicating content: an ideal representation format for a publisher distributing content to many consumers.   Representing documents and document-like structures: an ideal choice if your resources are structured like documents – just map the resource’s attributes to Atom’s metadata elements.   Creating metadata-rich lists of resources: if need to represent ordered lists, such as search results or events.   Atom metadata can represent event metadata, thereby establishing an event-oriented processing context for each Atom entry’s payload.  "},
{"word": "ATOM Publishing Protocol","description": "As a publishing protocol, AtomPub provides a standard mechanism for creating and editing resources, and resolving any arising conflicts.   It specifies the HTTP idioms that can be used to manipulate published content à Fits with REST API"},
{"word": "Category Documents","description": "Category documents contain lists of categories for categorizing collections and members.   A category list can be fixed, meaning it’s a closed set, or left open, allowing for subsequent extension.  "},
{"word": "Service Documents","description": "A service document acts as a well-known entry point into the collections hosted by a service.   From a service document, a client can navigate to the collections provided by the service"},
{"word": "Graph-like Models","description": "M-M relationships are an important factor in deciding which data model to go with 1-M (tree/doc), self-contained -> Document model M-M -> either relational or graph Highly M-M, complicated connections -> graph"},
{"word": "Graph-like Models","description": "Many kinds of data can be modelled as a graph       • Social Graph – vertices are people, edges indicate which people know each other       • The Web Graph – vertices are web pages and edges indicate HTML links to other pages       • Road or Rail networks vertices are junctions and edges represent the roads/railways between them"},
{"word": "Property Graph model:","description": "Each vertex:       • Identifier       • A set of outgoing edges       • A set of incoming edges       • A collection of properties (keyvalue pairs)Each edge:       • Identifier       • The vertex at which the edge starts (tail)       • The vertex at which the edge ends (head)       • A label for the relationship       • A collection of properties"},
{"word": "Namespaces in XML","description": "XML namespaces give elements and attributes a unique name across the Internet.  "},
{"word": "Accessing DB from an application","description": "When you work with a database system (regardless of its storage model) in an application, the code issues a query statements to the database via some form of “data-connectivity API” The application code blocks relating to using this library form “Data Access Layer” in the stack.         • For objects to persists, we need to convert the object values into the values that can be stored in the storage (relational tables, this case) – and convert them back upon retrieval.         • This should be done while preserving the properties of the objects and their relationships"},
{"word": "Impedance Mismatch Problem","description": "In application code: Objects can be either equal or identical: identical = same object (address) equal = same values In RDB, these two separate concepts do not exists.   There is only one concept of identify = primary key.   (i.  e.  , same primary key -> same objects) Potentially problematic, if duplicate objects are considered the same object (or vice versa) in database"},
{"word": "Rule Based Data Curation","description": "Evaluation:       • Is the process of assessing the precision of curation rules over time.   Adaptation:       • The process of improving the quality of rules"},
{"word": "Automated Data Curation","description": "      • Automated Data Curation intends to offloads analysts from data curation pipeline, and eases the process of data curation"},
{"word": "OMM","description": "Obtaining       • Extracting data from a variety of sources Massaging       • Transforming data into manageable form Managing       • Loading the data into a platform for use"},
{"word": "Obtaining Data","description": "Useful data can be found in many places       • on the Web, possibly via an API       • in documents in a file system       • in spreadsheets       • in videos       • etc.   etc.   etc.   and in a variety of formats"},
{"word": "Unformatted Text Data","description": "Unformatted text is generally unfriendly"},
{"word": "Data-driven organizations and data analytics","description": "      • Product and service recommendation       • Customer support       • Dashboard and reporting services       • Customer engagement       • Promotions and deals       • Product and service customization       • Communication"},
{"word": "Data used for analytics purposes","description": "structured data;   semi-structured data; unstructured data"},
{"word": "Marketing analytics","description": "      • Data collection and management       • Overall performance of your products (websites, apps, etc.  )       • Evaluate the content in your products       • Understand your audience       • Data visualization and analytics"},
{"word": "Machine Learning on AWS","description": "      • Provides Machine Learning as a service       • Allows for the integration of ML APIs with other tools in the platform, including data lakes and database tools       • Provides support for major ML frameworks like TensorFlow, PyTorch and Caffe2       • Access to computing infrastructure (e.  g.  , GPUs and FPGAs)"},
{"word": "Natural language conversational services","description": "      • Allows for building text and voice conversational interfaces       • Provides integration with other products such as Facebook Messenger, Amazon Alexa other platforms       • Leverages on domain knowledge and natural language understanding to comprehend what the end-user is saying"},
{"word": "Stanford Core NLP","description": "Natural language functionalities       • Part of speech       • Lemmas       • Named entities       • Dependency parse       • Relation extraction       • Coreference       • Sentiment analysis"}]